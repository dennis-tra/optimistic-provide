// Code generated by SQLBoiler 4.6.0 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/volatiletech/null/v8"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/sqlboiler/v4/types"
	"github.com/volatiletech/strmangle"
)

// Peer is an object representing the database table.
type Peer struct {
	ID           int               `boil:"id" json:"id" toml:"id" yaml:"id"`
	MultiHash    string            `boil:"multi_hash" json:"multi_hash" toml:"multi_hash" yaml:"multi_hash"`
	AgentVersion null.String       `boil:"agent_version" json:"agent_version,omitempty" toml:"agent_version" yaml:"agent_version,omitempty"`
	Protocols    types.StringArray `boil:"protocols" json:"protocols,omitempty" toml:"protocols" yaml:"protocols,omitempty"`
	UpdatedAt    time.Time         `boil:"updated_at" json:"updated_at" toml:"updated_at" yaml:"updated_at"`
	CreatedAt    time.Time         `boil:"created_at" json:"created_at" toml:"created_at" yaml:"created_at"`

	R *peerR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L peerL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var PeerColumns = struct {
	ID           string
	MultiHash    string
	AgentVersion string
	Protocols    string
	UpdatedAt    string
	CreatedAt    string
}{
	ID:           "id",
	MultiHash:    "multi_hash",
	AgentVersion: "agent_version",
	Protocols:    "protocols",
	UpdatedAt:    "updated_at",
	CreatedAt:    "created_at",
}

var PeerTableColumns = struct {
	ID           string
	MultiHash    string
	AgentVersion string
	Protocols    string
	UpdatedAt    string
	CreatedAt    string
}{
	ID:           "peers.id",
	MultiHash:    "peers.multi_hash",
	AgentVersion: "peers.agent_version",
	Protocols:    "peers.protocols",
	UpdatedAt:    "peers.updated_at",
	CreatedAt:    "peers.created_at",
}

// Generated where

type whereHelpertypes_StringArray struct{ field string }

func (w whereHelpertypes_StringArray) EQ(x types.StringArray) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, false, x)
}
func (w whereHelpertypes_StringArray) NEQ(x types.StringArray) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, true, x)
}
func (w whereHelpertypes_StringArray) IsNull() qm.QueryMod { return qmhelper.WhereIsNull(w.field) }
func (w whereHelpertypes_StringArray) IsNotNull() qm.QueryMod {
	return qmhelper.WhereIsNotNull(w.field)
}
func (w whereHelpertypes_StringArray) LT(x types.StringArray) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpertypes_StringArray) LTE(x types.StringArray) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpertypes_StringArray) GT(x types.StringArray) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpertypes_StringArray) GTE(x types.StringArray) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}

var PeerWhere = struct {
	ID           whereHelperint
	MultiHash    whereHelperstring
	AgentVersion whereHelpernull_String
	Protocols    whereHelpertypes_StringArray
	UpdatedAt    whereHelpertime_Time
	CreatedAt    whereHelpertime_Time
}{
	ID:           whereHelperint{field: "\"peers\".\"id\""},
	MultiHash:    whereHelperstring{field: "\"peers\".\"multi_hash\""},
	AgentVersion: whereHelpernull_String{field: "\"peers\".\"agent_version\""},
	Protocols:    whereHelpertypes_StringArray{field: "\"peers\".\"protocols\""},
	UpdatedAt:    whereHelpertime_Time{field: "\"peers\".\"updated_at\""},
	CreatedAt:    whereHelpertime_Time{field: "\"peers\".\"created_at\""},
}

// PeerRels is where relationship names are stored.
var PeerRels = struct {
	LocalAddProviderRPCS    string
	RemoteAddProviderRPCS   string
	CloserPeers             string
	LocalConnections        string
	RemoteConnections       string
	LocalDials              string
	RemoteDials             string
	LocalFindNodesRPCS      string
	RemoteFindNodesRPCS     string
	LocalGetProvidersRPCS   string
	RemoteGetProvidersRPCS  string
	Hosts                   string
	PeerLogs                string
	PeerStates              string
	ReferrerPeerStates      string
	HostProvideMeasurements string
	ProviderProviderPeers   string
	ProviderProvides        string
	RetrieverRetrievals     string
	RoutingTableEntries     string
	RoutingTableSnapshots   string
}{
	LocalAddProviderRPCS:    "LocalAddProviderRPCS",
	RemoteAddProviderRPCS:   "RemoteAddProviderRPCS",
	CloserPeers:             "CloserPeers",
	LocalConnections:        "LocalConnections",
	RemoteConnections:       "RemoteConnections",
	LocalDials:              "LocalDials",
	RemoteDials:             "RemoteDials",
	LocalFindNodesRPCS:      "LocalFindNodesRPCS",
	RemoteFindNodesRPCS:     "RemoteFindNodesRPCS",
	LocalGetProvidersRPCS:   "LocalGetProvidersRPCS",
	RemoteGetProvidersRPCS:  "RemoteGetProvidersRPCS",
	Hosts:                   "Hosts",
	PeerLogs:                "PeerLogs",
	PeerStates:              "PeerStates",
	ReferrerPeerStates:      "ReferrerPeerStates",
	HostProvideMeasurements: "HostProvideMeasurements",
	ProviderProviderPeers:   "ProviderProviderPeers",
	ProviderProvides:        "ProviderProvides",
	RetrieverRetrievals:     "RetrieverRetrievals",
	RoutingTableEntries:     "RoutingTableEntries",
	RoutingTableSnapshots:   "RoutingTableSnapshots",
}

// peerR is where relationships are stored.
type peerR struct {
	LocalAddProviderRPCS    AddProviderRPCSlice       `boil:"LocalAddProviderRPCS" json:"LocalAddProviderRPCS" toml:"LocalAddProviderRPCS" yaml:"LocalAddProviderRPCS"`
	RemoteAddProviderRPCS   AddProviderRPCSlice       `boil:"RemoteAddProviderRPCS" json:"RemoteAddProviderRPCS" toml:"RemoteAddProviderRPCS" yaml:"RemoteAddProviderRPCS"`
	CloserPeers             CloserPeerSlice           `boil:"CloserPeers" json:"CloserPeers" toml:"CloserPeers" yaml:"CloserPeers"`
	LocalConnections        ConnectionSlice           `boil:"LocalConnections" json:"LocalConnections" toml:"LocalConnections" yaml:"LocalConnections"`
	RemoteConnections       ConnectionSlice           `boil:"RemoteConnections" json:"RemoteConnections" toml:"RemoteConnections" yaml:"RemoteConnections"`
	LocalDials              DialSlice                 `boil:"LocalDials" json:"LocalDials" toml:"LocalDials" yaml:"LocalDials"`
	RemoteDials             DialSlice                 `boil:"RemoteDials" json:"RemoteDials" toml:"RemoteDials" yaml:"RemoteDials"`
	LocalFindNodesRPCS      FindNodesRPCSlice         `boil:"LocalFindNodesRPCS" json:"LocalFindNodesRPCS" toml:"LocalFindNodesRPCS" yaml:"LocalFindNodesRPCS"`
	RemoteFindNodesRPCS     FindNodesRPCSlice         `boil:"RemoteFindNodesRPCS" json:"RemoteFindNodesRPCS" toml:"RemoteFindNodesRPCS" yaml:"RemoteFindNodesRPCS"`
	LocalGetProvidersRPCS   GetProvidersRPCSlice      `boil:"LocalGetProvidersRPCS" json:"LocalGetProvidersRPCS" toml:"LocalGetProvidersRPCS" yaml:"LocalGetProvidersRPCS"`
	RemoteGetProvidersRPCS  GetProvidersRPCSlice      `boil:"RemoteGetProvidersRPCS" json:"RemoteGetProvidersRPCS" toml:"RemoteGetProvidersRPCS" yaml:"RemoteGetProvidersRPCS"`
	Hosts                   HostSlice                 `boil:"Hosts" json:"Hosts" toml:"Hosts" yaml:"Hosts"`
	PeerLogs                PeerLogSlice              `boil:"PeerLogs" json:"PeerLogs" toml:"PeerLogs" yaml:"PeerLogs"`
	PeerStates              PeerStateSlice            `boil:"PeerStates" json:"PeerStates" toml:"PeerStates" yaml:"PeerStates"`
	ReferrerPeerStates      PeerStateSlice            `boil:"ReferrerPeerStates" json:"ReferrerPeerStates" toml:"ReferrerPeerStates" yaml:"ReferrerPeerStates"`
	HostProvideMeasurements ProvideMeasurementSlice   `boil:"HostProvideMeasurements" json:"HostProvideMeasurements" toml:"HostProvideMeasurements" yaml:"HostProvideMeasurements"`
	ProviderProviderPeers   ProviderPeerSlice         `boil:"ProviderProviderPeers" json:"ProviderProviderPeers" toml:"ProviderProviderPeers" yaml:"ProviderProviderPeers"`
	ProviderProvides        ProvideSlice              `boil:"ProviderProvides" json:"ProviderProvides" toml:"ProviderProvides" yaml:"ProviderProvides"`
	RetrieverRetrievals     RetrievalSlice            `boil:"RetrieverRetrievals" json:"RetrieverRetrievals" toml:"RetrieverRetrievals" yaml:"RetrieverRetrievals"`
	RoutingTableEntries     RoutingTableEntrySlice    `boil:"RoutingTableEntries" json:"RoutingTableEntries" toml:"RoutingTableEntries" yaml:"RoutingTableEntries"`
	RoutingTableSnapshots   RoutingTableSnapshotSlice `boil:"RoutingTableSnapshots" json:"RoutingTableSnapshots" toml:"RoutingTableSnapshots" yaml:"RoutingTableSnapshots"`
}

// NewStruct creates a new relationship struct
func (*peerR) NewStruct() *peerR {
	return &peerR{}
}

// peerL is where Load methods for each relationship are stored.
type peerL struct{}

var (
	peerAllColumns            = []string{"id", "multi_hash", "agent_version", "protocols", "updated_at", "created_at"}
	peerColumnsWithoutDefault = []string{"multi_hash", "agent_version", "protocols", "updated_at", "created_at"}
	peerColumnsWithDefault    = []string{"id"}
	peerPrimaryKeyColumns     = []string{"id"}
)

type (
	// PeerSlice is an alias for a slice of pointers to Peer.
	// This should almost always be used instead of []Peer.
	PeerSlice []*Peer
	// PeerHook is the signature for custom Peer hook methods
	PeerHook func(context.Context, boil.ContextExecutor, *Peer) error

	peerQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	peerType                 = reflect.TypeOf(&Peer{})
	peerMapping              = queries.MakeStructMapping(peerType)
	peerPrimaryKeyMapping, _ = queries.BindMapping(peerType, peerMapping, peerPrimaryKeyColumns)
	peerInsertCacheMut       sync.RWMutex
	peerInsertCache          = make(map[string]insertCache)
	peerUpdateCacheMut       sync.RWMutex
	peerUpdateCache          = make(map[string]updateCache)
	peerUpsertCacheMut       sync.RWMutex
	peerUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var peerBeforeInsertHooks []PeerHook
var peerBeforeUpdateHooks []PeerHook
var peerBeforeDeleteHooks []PeerHook
var peerBeforeUpsertHooks []PeerHook

var peerAfterInsertHooks []PeerHook
var peerAfterSelectHooks []PeerHook
var peerAfterUpdateHooks []PeerHook
var peerAfterDeleteHooks []PeerHook
var peerAfterUpsertHooks []PeerHook

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *Peer) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range peerBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *Peer) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range peerBeforeUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *Peer) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range peerBeforeDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *Peer) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range peerBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *Peer) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range peerAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterSelectHooks executes all "after Select" hooks.
func (o *Peer) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range peerAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *Peer) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range peerAfterUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *Peer) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range peerAfterDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *Peer) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range peerAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddPeerHook registers your hook function for all future operations.
func AddPeerHook(hookPoint boil.HookPoint, peerHook PeerHook) {
	switch hookPoint {
	case boil.BeforeInsertHook:
		peerBeforeInsertHooks = append(peerBeforeInsertHooks, peerHook)
	case boil.BeforeUpdateHook:
		peerBeforeUpdateHooks = append(peerBeforeUpdateHooks, peerHook)
	case boil.BeforeDeleteHook:
		peerBeforeDeleteHooks = append(peerBeforeDeleteHooks, peerHook)
	case boil.BeforeUpsertHook:
		peerBeforeUpsertHooks = append(peerBeforeUpsertHooks, peerHook)
	case boil.AfterInsertHook:
		peerAfterInsertHooks = append(peerAfterInsertHooks, peerHook)
	case boil.AfterSelectHook:
		peerAfterSelectHooks = append(peerAfterSelectHooks, peerHook)
	case boil.AfterUpdateHook:
		peerAfterUpdateHooks = append(peerAfterUpdateHooks, peerHook)
	case boil.AfterDeleteHook:
		peerAfterDeleteHooks = append(peerAfterDeleteHooks, peerHook)
	case boil.AfterUpsertHook:
		peerAfterUpsertHooks = append(peerAfterUpsertHooks, peerHook)
	}
}

// One returns a single peer record from the query.
func (q peerQuery) One(ctx context.Context, exec boil.ContextExecutor) (*Peer, error) {
	o := &Peer{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: failed to execute a one query for peers")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all Peer records from the query.
func (q peerQuery) All(ctx context.Context, exec boil.ContextExecutor) (PeerSlice, error) {
	var o []*Peer

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "models: failed to assign all query results to Peer slice")
	}

	if len(peerAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all Peer records in the query.
func (q peerQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to count peers rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q peerQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "models: failed to check if peers exists")
	}

	return count > 0, nil
}

// LocalAddProviderRPCS retrieves all the add_provider_rpc's AddProviderRPCS with an executor via local_id column.
func (o *Peer) LocalAddProviderRPCS(mods ...qm.QueryMod) addProviderRPCQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"add_provider_rpcs\".\"local_id\"=?", o.ID),
	)

	query := AddProviderRPCS(queryMods...)
	queries.SetFrom(query.Query, "\"add_provider_rpcs\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"add_provider_rpcs\".*"})
	}

	return query
}

// RemoteAddProviderRPCS retrieves all the add_provider_rpc's AddProviderRPCS with an executor via remote_id column.
func (o *Peer) RemoteAddProviderRPCS(mods ...qm.QueryMod) addProviderRPCQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"add_provider_rpcs\".\"remote_id\"=?", o.ID),
	)

	query := AddProviderRPCS(queryMods...)
	queries.SetFrom(query.Query, "\"add_provider_rpcs\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"add_provider_rpcs\".*"})
	}

	return query
}

// CloserPeers retrieves all the closer_peer's CloserPeers with an executor.
func (o *Peer) CloserPeers(mods ...qm.QueryMod) closerPeerQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"closer_peers\".\"peer_id\"=?", o.ID),
	)

	query := CloserPeers(queryMods...)
	queries.SetFrom(query.Query, "\"closer_peers\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"closer_peers\".*"})
	}

	return query
}

// LocalConnections retrieves all the connection's Connections with an executor via local_id column.
func (o *Peer) LocalConnections(mods ...qm.QueryMod) connectionQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"connections\".\"local_id\"=?", o.ID),
	)

	query := Connections(queryMods...)
	queries.SetFrom(query.Query, "\"connections\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"connections\".*"})
	}

	return query
}

// RemoteConnections retrieves all the connection's Connections with an executor via remote_id column.
func (o *Peer) RemoteConnections(mods ...qm.QueryMod) connectionQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"connections\".\"remote_id\"=?", o.ID),
	)

	query := Connections(queryMods...)
	queries.SetFrom(query.Query, "\"connections\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"connections\".*"})
	}

	return query
}

// LocalDials retrieves all the dial's Dials with an executor via local_id column.
func (o *Peer) LocalDials(mods ...qm.QueryMod) dialQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"dials\".\"local_id\"=?", o.ID),
	)

	query := Dials(queryMods...)
	queries.SetFrom(query.Query, "\"dials\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"dials\".*"})
	}

	return query
}

// RemoteDials retrieves all the dial's Dials with an executor via remote_id column.
func (o *Peer) RemoteDials(mods ...qm.QueryMod) dialQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"dials\".\"remote_id\"=?", o.ID),
	)

	query := Dials(queryMods...)
	queries.SetFrom(query.Query, "\"dials\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"dials\".*"})
	}

	return query
}

// LocalFindNodesRPCS retrieves all the find_nodes_rpc's FindNodesRPCS with an executor via local_id column.
func (o *Peer) LocalFindNodesRPCS(mods ...qm.QueryMod) findNodesRPCQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"find_nodes_rpcs\".\"local_id\"=?", o.ID),
	)

	query := FindNodesRPCS(queryMods...)
	queries.SetFrom(query.Query, "\"find_nodes_rpcs\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"find_nodes_rpcs\".*"})
	}

	return query
}

// RemoteFindNodesRPCS retrieves all the find_nodes_rpc's FindNodesRPCS with an executor via remote_id column.
func (o *Peer) RemoteFindNodesRPCS(mods ...qm.QueryMod) findNodesRPCQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"find_nodes_rpcs\".\"remote_id\"=?", o.ID),
	)

	query := FindNodesRPCS(queryMods...)
	queries.SetFrom(query.Query, "\"find_nodes_rpcs\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"find_nodes_rpcs\".*"})
	}

	return query
}

// LocalGetProvidersRPCS retrieves all the get_providers_rpc's GetProvidersRPCS with an executor via local_id column.
func (o *Peer) LocalGetProvidersRPCS(mods ...qm.QueryMod) getProvidersRPCQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"get_providers_rpcs\".\"local_id\"=?", o.ID),
	)

	query := GetProvidersRPCS(queryMods...)
	queries.SetFrom(query.Query, "\"get_providers_rpcs\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"get_providers_rpcs\".*"})
	}

	return query
}

// RemoteGetProvidersRPCS retrieves all the get_providers_rpc's GetProvidersRPCS with an executor via remote_id column.
func (o *Peer) RemoteGetProvidersRPCS(mods ...qm.QueryMod) getProvidersRPCQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"get_providers_rpcs\".\"remote_id\"=?", o.ID),
	)

	query := GetProvidersRPCS(queryMods...)
	queries.SetFrom(query.Query, "\"get_providers_rpcs\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"get_providers_rpcs\".*"})
	}

	return query
}

// Hosts retrieves all the host's Hosts with an executor.
func (o *Peer) Hosts(mods ...qm.QueryMod) hostQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"hosts\".\"peer_id\"=?", o.ID),
	)

	query := Hosts(queryMods...)
	queries.SetFrom(query.Query, "\"hosts\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"hosts\".*"})
	}

	return query
}

// PeerLogs retrieves all the peer_log's PeerLogs with an executor.
func (o *Peer) PeerLogs(mods ...qm.QueryMod) peerLogQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"peer_logs\".\"peer_id\"=?", o.ID),
	)

	query := PeerLogs(queryMods...)
	queries.SetFrom(query.Query, "\"peer_logs\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"peer_logs\".*"})
	}

	return query
}

// PeerStates retrieves all the peer_state's PeerStates with an executor.
func (o *Peer) PeerStates(mods ...qm.QueryMod) peerStateQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"peer_states\".\"peer_id\"=?", o.ID),
	)

	query := PeerStates(queryMods...)
	queries.SetFrom(query.Query, "\"peer_states\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"peer_states\".*"})
	}

	return query
}

// ReferrerPeerStates retrieves all the peer_state's PeerStates with an executor via referrer_id column.
func (o *Peer) ReferrerPeerStates(mods ...qm.QueryMod) peerStateQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"peer_states\".\"referrer_id\"=?", o.ID),
	)

	query := PeerStates(queryMods...)
	queries.SetFrom(query.Query, "\"peer_states\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"peer_states\".*"})
	}

	return query
}

// HostProvideMeasurements retrieves all the provide_measurement's ProvideMeasurements with an executor via host_id column.
func (o *Peer) HostProvideMeasurements(mods ...qm.QueryMod) provideMeasurementQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"provide_measurements\".\"host_id\"=?", o.ID),
	)

	query := ProvideMeasurements(queryMods...)
	queries.SetFrom(query.Query, "\"provide_measurements\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"provide_measurements\".*"})
	}

	return query
}

// ProviderProviderPeers retrieves all the provider_peer's ProviderPeers with an executor via provider_id column.
func (o *Peer) ProviderProviderPeers(mods ...qm.QueryMod) providerPeerQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"provider_peers\".\"provider_id\"=?", o.ID),
	)

	query := ProviderPeers(queryMods...)
	queries.SetFrom(query.Query, "\"provider_peers\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"provider_peers\".*"})
	}

	return query
}

// ProviderProvides retrieves all the provide's Provides with an executor via provider_id column.
func (o *Peer) ProviderProvides(mods ...qm.QueryMod) provideQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"provides\".\"provider_id\"=?", o.ID),
	)

	query := Provides(queryMods...)
	queries.SetFrom(query.Query, "\"provides\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"provides\".*"})
	}

	return query
}

// RetrieverRetrievals retrieves all the retrieval's Retrievals with an executor via retriever_id column.
func (o *Peer) RetrieverRetrievals(mods ...qm.QueryMod) retrievalQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"retrievals\".\"retriever_id\"=?", o.ID),
	)

	query := Retrievals(queryMods...)
	queries.SetFrom(query.Query, "\"retrievals\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"retrievals\".*"})
	}

	return query
}

// RoutingTableEntries retrieves all the routing_table_entry's RoutingTableEntries with an executor.
func (o *Peer) RoutingTableEntries(mods ...qm.QueryMod) routingTableEntryQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"routing_table_entries\".\"peer_id\"=?", o.ID),
	)

	query := RoutingTableEntries(queryMods...)
	queries.SetFrom(query.Query, "\"routing_table_entries\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"routing_table_entries\".*"})
	}

	return query
}

// RoutingTableSnapshots retrieves all the routing_table_snapshot's RoutingTableSnapshots with an executor.
func (o *Peer) RoutingTableSnapshots(mods ...qm.QueryMod) routingTableSnapshotQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"routing_table_snapshots\".\"peer_id\"=?", o.ID),
	)

	query := RoutingTableSnapshots(queryMods...)
	queries.SetFrom(query.Query, "\"routing_table_snapshots\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"routing_table_snapshots\".*"})
	}

	return query
}

// LoadLocalAddProviderRPCS allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (peerL) LoadLocalAddProviderRPCS(ctx context.Context, e boil.ContextExecutor, singular bool, maybePeer interface{}, mods queries.Applicator) error {
	var slice []*Peer
	var object *Peer

	if singular {
		object = maybePeer.(*Peer)
	} else {
		slice = *maybePeer.(*[]*Peer)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &peerR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &peerR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`add_provider_rpcs`),
		qm.WhereIn(`add_provider_rpcs.local_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load add_provider_rpcs")
	}

	var resultSlice []*AddProviderRPC
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice add_provider_rpcs")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on add_provider_rpcs")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for add_provider_rpcs")
	}

	if len(addProviderRPCAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.LocalAddProviderRPCS = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &addProviderRPCR{}
			}
			foreign.R.Local = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.LocalID {
				local.R.LocalAddProviderRPCS = append(local.R.LocalAddProviderRPCS, foreign)
				if foreign.R == nil {
					foreign.R = &addProviderRPCR{}
				}
				foreign.R.Local = local
				break
			}
		}
	}

	return nil
}

// LoadRemoteAddProviderRPCS allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (peerL) LoadRemoteAddProviderRPCS(ctx context.Context, e boil.ContextExecutor, singular bool, maybePeer interface{}, mods queries.Applicator) error {
	var slice []*Peer
	var object *Peer

	if singular {
		object = maybePeer.(*Peer)
	} else {
		slice = *maybePeer.(*[]*Peer)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &peerR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &peerR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`add_provider_rpcs`),
		qm.WhereIn(`add_provider_rpcs.remote_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load add_provider_rpcs")
	}

	var resultSlice []*AddProviderRPC
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice add_provider_rpcs")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on add_provider_rpcs")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for add_provider_rpcs")
	}

	if len(addProviderRPCAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.RemoteAddProviderRPCS = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &addProviderRPCR{}
			}
			foreign.R.Remote = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.RemoteID {
				local.R.RemoteAddProviderRPCS = append(local.R.RemoteAddProviderRPCS, foreign)
				if foreign.R == nil {
					foreign.R = &addProviderRPCR{}
				}
				foreign.R.Remote = local
				break
			}
		}
	}

	return nil
}

// LoadCloserPeers allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (peerL) LoadCloserPeers(ctx context.Context, e boil.ContextExecutor, singular bool, maybePeer interface{}, mods queries.Applicator) error {
	var slice []*Peer
	var object *Peer

	if singular {
		object = maybePeer.(*Peer)
	} else {
		slice = *maybePeer.(*[]*Peer)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &peerR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &peerR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`closer_peers`),
		qm.WhereIn(`closer_peers.peer_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load closer_peers")
	}

	var resultSlice []*CloserPeer
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice closer_peers")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on closer_peers")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for closer_peers")
	}

	if len(closerPeerAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.CloserPeers = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &closerPeerR{}
			}
			foreign.R.Peer = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.PeerID {
				local.R.CloserPeers = append(local.R.CloserPeers, foreign)
				if foreign.R == nil {
					foreign.R = &closerPeerR{}
				}
				foreign.R.Peer = local
				break
			}
		}
	}

	return nil
}

// LoadLocalConnections allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (peerL) LoadLocalConnections(ctx context.Context, e boil.ContextExecutor, singular bool, maybePeer interface{}, mods queries.Applicator) error {
	var slice []*Peer
	var object *Peer

	if singular {
		object = maybePeer.(*Peer)
	} else {
		slice = *maybePeer.(*[]*Peer)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &peerR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &peerR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`connections`),
		qm.WhereIn(`connections.local_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load connections")
	}

	var resultSlice []*Connection
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice connections")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on connections")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for connections")
	}

	if len(connectionAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.LocalConnections = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &connectionR{}
			}
			foreign.R.Local = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.LocalID {
				local.R.LocalConnections = append(local.R.LocalConnections, foreign)
				if foreign.R == nil {
					foreign.R = &connectionR{}
				}
				foreign.R.Local = local
				break
			}
		}
	}

	return nil
}

// LoadRemoteConnections allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (peerL) LoadRemoteConnections(ctx context.Context, e boil.ContextExecutor, singular bool, maybePeer interface{}, mods queries.Applicator) error {
	var slice []*Peer
	var object *Peer

	if singular {
		object = maybePeer.(*Peer)
	} else {
		slice = *maybePeer.(*[]*Peer)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &peerR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &peerR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`connections`),
		qm.WhereIn(`connections.remote_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load connections")
	}

	var resultSlice []*Connection
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice connections")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on connections")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for connections")
	}

	if len(connectionAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.RemoteConnections = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &connectionR{}
			}
			foreign.R.Remote = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.RemoteID {
				local.R.RemoteConnections = append(local.R.RemoteConnections, foreign)
				if foreign.R == nil {
					foreign.R = &connectionR{}
				}
				foreign.R.Remote = local
				break
			}
		}
	}

	return nil
}

// LoadLocalDials allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (peerL) LoadLocalDials(ctx context.Context, e boil.ContextExecutor, singular bool, maybePeer interface{}, mods queries.Applicator) error {
	var slice []*Peer
	var object *Peer

	if singular {
		object = maybePeer.(*Peer)
	} else {
		slice = *maybePeer.(*[]*Peer)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &peerR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &peerR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`dials`),
		qm.WhereIn(`dials.local_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load dials")
	}

	var resultSlice []*Dial
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice dials")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on dials")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for dials")
	}

	if len(dialAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.LocalDials = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &dialR{}
			}
			foreign.R.Local = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.LocalID {
				local.R.LocalDials = append(local.R.LocalDials, foreign)
				if foreign.R == nil {
					foreign.R = &dialR{}
				}
				foreign.R.Local = local
				break
			}
		}
	}

	return nil
}

// LoadRemoteDials allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (peerL) LoadRemoteDials(ctx context.Context, e boil.ContextExecutor, singular bool, maybePeer interface{}, mods queries.Applicator) error {
	var slice []*Peer
	var object *Peer

	if singular {
		object = maybePeer.(*Peer)
	} else {
		slice = *maybePeer.(*[]*Peer)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &peerR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &peerR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`dials`),
		qm.WhereIn(`dials.remote_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load dials")
	}

	var resultSlice []*Dial
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice dials")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on dials")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for dials")
	}

	if len(dialAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.RemoteDials = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &dialR{}
			}
			foreign.R.Remote = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.RemoteID {
				local.R.RemoteDials = append(local.R.RemoteDials, foreign)
				if foreign.R == nil {
					foreign.R = &dialR{}
				}
				foreign.R.Remote = local
				break
			}
		}
	}

	return nil
}

// LoadLocalFindNodesRPCS allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (peerL) LoadLocalFindNodesRPCS(ctx context.Context, e boil.ContextExecutor, singular bool, maybePeer interface{}, mods queries.Applicator) error {
	var slice []*Peer
	var object *Peer

	if singular {
		object = maybePeer.(*Peer)
	} else {
		slice = *maybePeer.(*[]*Peer)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &peerR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &peerR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`find_nodes_rpcs`),
		qm.WhereIn(`find_nodes_rpcs.local_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load find_nodes_rpcs")
	}

	var resultSlice []*FindNodesRPC
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice find_nodes_rpcs")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on find_nodes_rpcs")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for find_nodes_rpcs")
	}

	if len(findNodesRPCAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.LocalFindNodesRPCS = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &findNodesRPCR{}
			}
			foreign.R.Local = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.LocalID {
				local.R.LocalFindNodesRPCS = append(local.R.LocalFindNodesRPCS, foreign)
				if foreign.R == nil {
					foreign.R = &findNodesRPCR{}
				}
				foreign.R.Local = local
				break
			}
		}
	}

	return nil
}

// LoadRemoteFindNodesRPCS allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (peerL) LoadRemoteFindNodesRPCS(ctx context.Context, e boil.ContextExecutor, singular bool, maybePeer interface{}, mods queries.Applicator) error {
	var slice []*Peer
	var object *Peer

	if singular {
		object = maybePeer.(*Peer)
	} else {
		slice = *maybePeer.(*[]*Peer)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &peerR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &peerR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`find_nodes_rpcs`),
		qm.WhereIn(`find_nodes_rpcs.remote_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load find_nodes_rpcs")
	}

	var resultSlice []*FindNodesRPC
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice find_nodes_rpcs")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on find_nodes_rpcs")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for find_nodes_rpcs")
	}

	if len(findNodesRPCAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.RemoteFindNodesRPCS = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &findNodesRPCR{}
			}
			foreign.R.Remote = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.RemoteID {
				local.R.RemoteFindNodesRPCS = append(local.R.RemoteFindNodesRPCS, foreign)
				if foreign.R == nil {
					foreign.R = &findNodesRPCR{}
				}
				foreign.R.Remote = local
				break
			}
		}
	}

	return nil
}

// LoadLocalGetProvidersRPCS allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (peerL) LoadLocalGetProvidersRPCS(ctx context.Context, e boil.ContextExecutor, singular bool, maybePeer interface{}, mods queries.Applicator) error {
	var slice []*Peer
	var object *Peer

	if singular {
		object = maybePeer.(*Peer)
	} else {
		slice = *maybePeer.(*[]*Peer)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &peerR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &peerR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`get_providers_rpcs`),
		qm.WhereIn(`get_providers_rpcs.local_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load get_providers_rpcs")
	}

	var resultSlice []*GetProvidersRPC
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice get_providers_rpcs")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on get_providers_rpcs")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for get_providers_rpcs")
	}

	if len(getProvidersRPCAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.LocalGetProvidersRPCS = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &getProvidersRPCR{}
			}
			foreign.R.Local = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.LocalID {
				local.R.LocalGetProvidersRPCS = append(local.R.LocalGetProvidersRPCS, foreign)
				if foreign.R == nil {
					foreign.R = &getProvidersRPCR{}
				}
				foreign.R.Local = local
				break
			}
		}
	}

	return nil
}

// LoadRemoteGetProvidersRPCS allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (peerL) LoadRemoteGetProvidersRPCS(ctx context.Context, e boil.ContextExecutor, singular bool, maybePeer interface{}, mods queries.Applicator) error {
	var slice []*Peer
	var object *Peer

	if singular {
		object = maybePeer.(*Peer)
	} else {
		slice = *maybePeer.(*[]*Peer)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &peerR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &peerR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`get_providers_rpcs`),
		qm.WhereIn(`get_providers_rpcs.remote_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load get_providers_rpcs")
	}

	var resultSlice []*GetProvidersRPC
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice get_providers_rpcs")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on get_providers_rpcs")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for get_providers_rpcs")
	}

	if len(getProvidersRPCAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.RemoteGetProvidersRPCS = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &getProvidersRPCR{}
			}
			foreign.R.Remote = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.RemoteID {
				local.R.RemoteGetProvidersRPCS = append(local.R.RemoteGetProvidersRPCS, foreign)
				if foreign.R == nil {
					foreign.R = &getProvidersRPCR{}
				}
				foreign.R.Remote = local
				break
			}
		}
	}

	return nil
}

// LoadHosts allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (peerL) LoadHosts(ctx context.Context, e boil.ContextExecutor, singular bool, maybePeer interface{}, mods queries.Applicator) error {
	var slice []*Peer
	var object *Peer

	if singular {
		object = maybePeer.(*Peer)
	} else {
		slice = *maybePeer.(*[]*Peer)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &peerR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &peerR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`hosts`),
		qm.WhereIn(`hosts.peer_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load hosts")
	}

	var resultSlice []*Host
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice hosts")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on hosts")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for hosts")
	}

	if len(hostAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.Hosts = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &hostR{}
			}
			foreign.R.Peer = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.PeerID {
				local.R.Hosts = append(local.R.Hosts, foreign)
				if foreign.R == nil {
					foreign.R = &hostR{}
				}
				foreign.R.Peer = local
				break
			}
		}
	}

	return nil
}

// LoadPeerLogs allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (peerL) LoadPeerLogs(ctx context.Context, e boil.ContextExecutor, singular bool, maybePeer interface{}, mods queries.Applicator) error {
	var slice []*Peer
	var object *Peer

	if singular {
		object = maybePeer.(*Peer)
	} else {
		slice = *maybePeer.(*[]*Peer)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &peerR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &peerR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`peer_logs`),
		qm.WhereIn(`peer_logs.peer_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load peer_logs")
	}

	var resultSlice []*PeerLog
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice peer_logs")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on peer_logs")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for peer_logs")
	}

	if len(peerLogAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.PeerLogs = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &peerLogR{}
			}
			foreign.R.Peer = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.PeerID {
				local.R.PeerLogs = append(local.R.PeerLogs, foreign)
				if foreign.R == nil {
					foreign.R = &peerLogR{}
				}
				foreign.R.Peer = local
				break
			}
		}
	}

	return nil
}

// LoadPeerStates allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (peerL) LoadPeerStates(ctx context.Context, e boil.ContextExecutor, singular bool, maybePeer interface{}, mods queries.Applicator) error {
	var slice []*Peer
	var object *Peer

	if singular {
		object = maybePeer.(*Peer)
	} else {
		slice = *maybePeer.(*[]*Peer)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &peerR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &peerR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`peer_states`),
		qm.WhereIn(`peer_states.peer_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load peer_states")
	}

	var resultSlice []*PeerState
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice peer_states")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on peer_states")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for peer_states")
	}

	if len(peerStateAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.PeerStates = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &peerStateR{}
			}
			foreign.R.Peer = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.PeerID {
				local.R.PeerStates = append(local.R.PeerStates, foreign)
				if foreign.R == nil {
					foreign.R = &peerStateR{}
				}
				foreign.R.Peer = local
				break
			}
		}
	}

	return nil
}

// LoadReferrerPeerStates allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (peerL) LoadReferrerPeerStates(ctx context.Context, e boil.ContextExecutor, singular bool, maybePeer interface{}, mods queries.Applicator) error {
	var slice []*Peer
	var object *Peer

	if singular {
		object = maybePeer.(*Peer)
	} else {
		slice = *maybePeer.(*[]*Peer)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &peerR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &peerR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`peer_states`),
		qm.WhereIn(`peer_states.referrer_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load peer_states")
	}

	var resultSlice []*PeerState
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice peer_states")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on peer_states")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for peer_states")
	}

	if len(peerStateAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.ReferrerPeerStates = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &peerStateR{}
			}
			foreign.R.Referrer = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.ReferrerID {
				local.R.ReferrerPeerStates = append(local.R.ReferrerPeerStates, foreign)
				if foreign.R == nil {
					foreign.R = &peerStateR{}
				}
				foreign.R.Referrer = local
				break
			}
		}
	}

	return nil
}

// LoadHostProvideMeasurements allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (peerL) LoadHostProvideMeasurements(ctx context.Context, e boil.ContextExecutor, singular bool, maybePeer interface{}, mods queries.Applicator) error {
	var slice []*Peer
	var object *Peer

	if singular {
		object = maybePeer.(*Peer)
	} else {
		slice = *maybePeer.(*[]*Peer)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &peerR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &peerR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`provide_measurements`),
		qm.WhereIn(`provide_measurements.host_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load provide_measurements")
	}

	var resultSlice []*ProvideMeasurement
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice provide_measurements")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on provide_measurements")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for provide_measurements")
	}

	if len(provideMeasurementAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.HostProvideMeasurements = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &provideMeasurementR{}
			}
			foreign.R.Host = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.HostID {
				local.R.HostProvideMeasurements = append(local.R.HostProvideMeasurements, foreign)
				if foreign.R == nil {
					foreign.R = &provideMeasurementR{}
				}
				foreign.R.Host = local
				break
			}
		}
	}

	return nil
}

// LoadProviderProviderPeers allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (peerL) LoadProviderProviderPeers(ctx context.Context, e boil.ContextExecutor, singular bool, maybePeer interface{}, mods queries.Applicator) error {
	var slice []*Peer
	var object *Peer

	if singular {
		object = maybePeer.(*Peer)
	} else {
		slice = *maybePeer.(*[]*Peer)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &peerR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &peerR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`provider_peers`),
		qm.WhereIn(`provider_peers.provider_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load provider_peers")
	}

	var resultSlice []*ProviderPeer
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice provider_peers")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on provider_peers")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for provider_peers")
	}

	if len(providerPeerAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.ProviderProviderPeers = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &providerPeerR{}
			}
			foreign.R.Provider = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.ProviderID {
				local.R.ProviderProviderPeers = append(local.R.ProviderProviderPeers, foreign)
				if foreign.R == nil {
					foreign.R = &providerPeerR{}
				}
				foreign.R.Provider = local
				break
			}
		}
	}

	return nil
}

// LoadProviderProvides allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (peerL) LoadProviderProvides(ctx context.Context, e boil.ContextExecutor, singular bool, maybePeer interface{}, mods queries.Applicator) error {
	var slice []*Peer
	var object *Peer

	if singular {
		object = maybePeer.(*Peer)
	} else {
		slice = *maybePeer.(*[]*Peer)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &peerR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &peerR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`provides`),
		qm.WhereIn(`provides.provider_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load provides")
	}

	var resultSlice []*Provide
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice provides")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on provides")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for provides")
	}

	if len(provideAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.ProviderProvides = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &provideR{}
			}
			foreign.R.Provider = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.ProviderID {
				local.R.ProviderProvides = append(local.R.ProviderProvides, foreign)
				if foreign.R == nil {
					foreign.R = &provideR{}
				}
				foreign.R.Provider = local
				break
			}
		}
	}

	return nil
}

// LoadRetrieverRetrievals allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (peerL) LoadRetrieverRetrievals(ctx context.Context, e boil.ContextExecutor, singular bool, maybePeer interface{}, mods queries.Applicator) error {
	var slice []*Peer
	var object *Peer

	if singular {
		object = maybePeer.(*Peer)
	} else {
		slice = *maybePeer.(*[]*Peer)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &peerR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &peerR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`retrievals`),
		qm.WhereIn(`retrievals.retriever_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load retrievals")
	}

	var resultSlice []*Retrieval
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice retrievals")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on retrievals")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for retrievals")
	}

	if len(retrievalAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.RetrieverRetrievals = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &retrievalR{}
			}
			foreign.R.Retriever = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.RetrieverID {
				local.R.RetrieverRetrievals = append(local.R.RetrieverRetrievals, foreign)
				if foreign.R == nil {
					foreign.R = &retrievalR{}
				}
				foreign.R.Retriever = local
				break
			}
		}
	}

	return nil
}

// LoadRoutingTableEntries allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (peerL) LoadRoutingTableEntries(ctx context.Context, e boil.ContextExecutor, singular bool, maybePeer interface{}, mods queries.Applicator) error {
	var slice []*Peer
	var object *Peer

	if singular {
		object = maybePeer.(*Peer)
	} else {
		slice = *maybePeer.(*[]*Peer)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &peerR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &peerR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`routing_table_entries`),
		qm.WhereIn(`routing_table_entries.peer_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load routing_table_entries")
	}

	var resultSlice []*RoutingTableEntry
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice routing_table_entries")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on routing_table_entries")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for routing_table_entries")
	}

	if len(routingTableEntryAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.RoutingTableEntries = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &routingTableEntryR{}
			}
			foreign.R.Peer = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.PeerID {
				local.R.RoutingTableEntries = append(local.R.RoutingTableEntries, foreign)
				if foreign.R == nil {
					foreign.R = &routingTableEntryR{}
				}
				foreign.R.Peer = local
				break
			}
		}
	}

	return nil
}

// LoadRoutingTableSnapshots allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (peerL) LoadRoutingTableSnapshots(ctx context.Context, e boil.ContextExecutor, singular bool, maybePeer interface{}, mods queries.Applicator) error {
	var slice []*Peer
	var object *Peer

	if singular {
		object = maybePeer.(*Peer)
	} else {
		slice = *maybePeer.(*[]*Peer)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &peerR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &peerR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`routing_table_snapshots`),
		qm.WhereIn(`routing_table_snapshots.peer_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load routing_table_snapshots")
	}

	var resultSlice []*RoutingTableSnapshot
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice routing_table_snapshots")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on routing_table_snapshots")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for routing_table_snapshots")
	}

	if len(routingTableSnapshotAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.RoutingTableSnapshots = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &routingTableSnapshotR{}
			}
			foreign.R.Peer = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.PeerID {
				local.R.RoutingTableSnapshots = append(local.R.RoutingTableSnapshots, foreign)
				if foreign.R == nil {
					foreign.R = &routingTableSnapshotR{}
				}
				foreign.R.Peer = local
				break
			}
		}
	}

	return nil
}

// AddLocalAddProviderRPCS adds the given related objects to the existing relationships
// of the peer, optionally inserting them as new records.
// Appends related to o.R.LocalAddProviderRPCS.
// Sets related.R.Local appropriately.
func (o *Peer) AddLocalAddProviderRPCS(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*AddProviderRPC) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.LocalID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"add_provider_rpcs\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"local_id"}),
				strmangle.WhereClause("\"", "\"", 2, addProviderRPCPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.LocalID = o.ID
		}
	}

	if o.R == nil {
		o.R = &peerR{
			LocalAddProviderRPCS: related,
		}
	} else {
		o.R.LocalAddProviderRPCS = append(o.R.LocalAddProviderRPCS, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &addProviderRPCR{
				Local: o,
			}
		} else {
			rel.R.Local = o
		}
	}
	return nil
}

// AddRemoteAddProviderRPCS adds the given related objects to the existing relationships
// of the peer, optionally inserting them as new records.
// Appends related to o.R.RemoteAddProviderRPCS.
// Sets related.R.Remote appropriately.
func (o *Peer) AddRemoteAddProviderRPCS(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*AddProviderRPC) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.RemoteID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"add_provider_rpcs\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"remote_id"}),
				strmangle.WhereClause("\"", "\"", 2, addProviderRPCPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.RemoteID = o.ID
		}
	}

	if o.R == nil {
		o.R = &peerR{
			RemoteAddProviderRPCS: related,
		}
	} else {
		o.R.RemoteAddProviderRPCS = append(o.R.RemoteAddProviderRPCS, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &addProviderRPCR{
				Remote: o,
			}
		} else {
			rel.R.Remote = o
		}
	}
	return nil
}

// AddCloserPeers adds the given related objects to the existing relationships
// of the peer, optionally inserting them as new records.
// Appends related to o.R.CloserPeers.
// Sets related.R.Peer appropriately.
func (o *Peer) AddCloserPeers(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*CloserPeer) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.PeerID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"closer_peers\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"peer_id"}),
				strmangle.WhereClause("\"", "\"", 2, closerPeerPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.PeerID = o.ID
		}
	}

	if o.R == nil {
		o.R = &peerR{
			CloserPeers: related,
		}
	} else {
		o.R.CloserPeers = append(o.R.CloserPeers, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &closerPeerR{
				Peer: o,
			}
		} else {
			rel.R.Peer = o
		}
	}
	return nil
}

// AddLocalConnections adds the given related objects to the existing relationships
// of the peer, optionally inserting them as new records.
// Appends related to o.R.LocalConnections.
// Sets related.R.Local appropriately.
func (o *Peer) AddLocalConnections(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Connection) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.LocalID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"connections\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"local_id"}),
				strmangle.WhereClause("\"", "\"", 2, connectionPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.LocalID = o.ID
		}
	}

	if o.R == nil {
		o.R = &peerR{
			LocalConnections: related,
		}
	} else {
		o.R.LocalConnections = append(o.R.LocalConnections, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &connectionR{
				Local: o,
			}
		} else {
			rel.R.Local = o
		}
	}
	return nil
}

// AddRemoteConnections adds the given related objects to the existing relationships
// of the peer, optionally inserting them as new records.
// Appends related to o.R.RemoteConnections.
// Sets related.R.Remote appropriately.
func (o *Peer) AddRemoteConnections(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Connection) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.RemoteID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"connections\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"remote_id"}),
				strmangle.WhereClause("\"", "\"", 2, connectionPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.RemoteID = o.ID
		}
	}

	if o.R == nil {
		o.R = &peerR{
			RemoteConnections: related,
		}
	} else {
		o.R.RemoteConnections = append(o.R.RemoteConnections, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &connectionR{
				Remote: o,
			}
		} else {
			rel.R.Remote = o
		}
	}
	return nil
}

// AddLocalDials adds the given related objects to the existing relationships
// of the peer, optionally inserting them as new records.
// Appends related to o.R.LocalDials.
// Sets related.R.Local appropriately.
func (o *Peer) AddLocalDials(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Dial) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.LocalID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"dials\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"local_id"}),
				strmangle.WhereClause("\"", "\"", 2, dialPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.LocalID = o.ID
		}
	}

	if o.R == nil {
		o.R = &peerR{
			LocalDials: related,
		}
	} else {
		o.R.LocalDials = append(o.R.LocalDials, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &dialR{
				Local: o,
			}
		} else {
			rel.R.Local = o
		}
	}
	return nil
}

// AddRemoteDials adds the given related objects to the existing relationships
// of the peer, optionally inserting them as new records.
// Appends related to o.R.RemoteDials.
// Sets related.R.Remote appropriately.
func (o *Peer) AddRemoteDials(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Dial) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.RemoteID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"dials\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"remote_id"}),
				strmangle.WhereClause("\"", "\"", 2, dialPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.RemoteID = o.ID
		}
	}

	if o.R == nil {
		o.R = &peerR{
			RemoteDials: related,
		}
	} else {
		o.R.RemoteDials = append(o.R.RemoteDials, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &dialR{
				Remote: o,
			}
		} else {
			rel.R.Remote = o
		}
	}
	return nil
}

// AddLocalFindNodesRPCS adds the given related objects to the existing relationships
// of the peer, optionally inserting them as new records.
// Appends related to o.R.LocalFindNodesRPCS.
// Sets related.R.Local appropriately.
func (o *Peer) AddLocalFindNodesRPCS(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*FindNodesRPC) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.LocalID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"find_nodes_rpcs\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"local_id"}),
				strmangle.WhereClause("\"", "\"", 2, findNodesRPCPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.LocalID = o.ID
		}
	}

	if o.R == nil {
		o.R = &peerR{
			LocalFindNodesRPCS: related,
		}
	} else {
		o.R.LocalFindNodesRPCS = append(o.R.LocalFindNodesRPCS, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &findNodesRPCR{
				Local: o,
			}
		} else {
			rel.R.Local = o
		}
	}
	return nil
}

// AddRemoteFindNodesRPCS adds the given related objects to the existing relationships
// of the peer, optionally inserting them as new records.
// Appends related to o.R.RemoteFindNodesRPCS.
// Sets related.R.Remote appropriately.
func (o *Peer) AddRemoteFindNodesRPCS(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*FindNodesRPC) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.RemoteID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"find_nodes_rpcs\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"remote_id"}),
				strmangle.WhereClause("\"", "\"", 2, findNodesRPCPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.RemoteID = o.ID
		}
	}

	if o.R == nil {
		o.R = &peerR{
			RemoteFindNodesRPCS: related,
		}
	} else {
		o.R.RemoteFindNodesRPCS = append(o.R.RemoteFindNodesRPCS, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &findNodesRPCR{
				Remote: o,
			}
		} else {
			rel.R.Remote = o
		}
	}
	return nil
}

// AddLocalGetProvidersRPCS adds the given related objects to the existing relationships
// of the peer, optionally inserting them as new records.
// Appends related to o.R.LocalGetProvidersRPCS.
// Sets related.R.Local appropriately.
func (o *Peer) AddLocalGetProvidersRPCS(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*GetProvidersRPC) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.LocalID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"get_providers_rpcs\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"local_id"}),
				strmangle.WhereClause("\"", "\"", 2, getProvidersRPCPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.LocalID = o.ID
		}
	}

	if o.R == nil {
		o.R = &peerR{
			LocalGetProvidersRPCS: related,
		}
	} else {
		o.R.LocalGetProvidersRPCS = append(o.R.LocalGetProvidersRPCS, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &getProvidersRPCR{
				Local: o,
			}
		} else {
			rel.R.Local = o
		}
	}
	return nil
}

// AddRemoteGetProvidersRPCS adds the given related objects to the existing relationships
// of the peer, optionally inserting them as new records.
// Appends related to o.R.RemoteGetProvidersRPCS.
// Sets related.R.Remote appropriately.
func (o *Peer) AddRemoteGetProvidersRPCS(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*GetProvidersRPC) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.RemoteID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"get_providers_rpcs\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"remote_id"}),
				strmangle.WhereClause("\"", "\"", 2, getProvidersRPCPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.RemoteID = o.ID
		}
	}

	if o.R == nil {
		o.R = &peerR{
			RemoteGetProvidersRPCS: related,
		}
	} else {
		o.R.RemoteGetProvidersRPCS = append(o.R.RemoteGetProvidersRPCS, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &getProvidersRPCR{
				Remote: o,
			}
		} else {
			rel.R.Remote = o
		}
	}
	return nil
}

// AddHosts adds the given related objects to the existing relationships
// of the peer, optionally inserting them as new records.
// Appends related to o.R.Hosts.
// Sets related.R.Peer appropriately.
func (o *Peer) AddHosts(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Host) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.PeerID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"hosts\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"peer_id"}),
				strmangle.WhereClause("\"", "\"", 2, hostPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.PeerID = o.ID
		}
	}

	if o.R == nil {
		o.R = &peerR{
			Hosts: related,
		}
	} else {
		o.R.Hosts = append(o.R.Hosts, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &hostR{
				Peer: o,
			}
		} else {
			rel.R.Peer = o
		}
	}
	return nil
}

// AddPeerLogs adds the given related objects to the existing relationships
// of the peer, optionally inserting them as new records.
// Appends related to o.R.PeerLogs.
// Sets related.R.Peer appropriately.
func (o *Peer) AddPeerLogs(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*PeerLog) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.PeerID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"peer_logs\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"peer_id"}),
				strmangle.WhereClause("\"", "\"", 2, peerLogPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.PeerID = o.ID
		}
	}

	if o.R == nil {
		o.R = &peerR{
			PeerLogs: related,
		}
	} else {
		o.R.PeerLogs = append(o.R.PeerLogs, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &peerLogR{
				Peer: o,
			}
		} else {
			rel.R.Peer = o
		}
	}
	return nil
}

// AddPeerStates adds the given related objects to the existing relationships
// of the peer, optionally inserting them as new records.
// Appends related to o.R.PeerStates.
// Sets related.R.Peer appropriately.
func (o *Peer) AddPeerStates(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*PeerState) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.PeerID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"peer_states\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"peer_id"}),
				strmangle.WhereClause("\"", "\"", 2, peerStatePrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.PeerID = o.ID
		}
	}

	if o.R == nil {
		o.R = &peerR{
			PeerStates: related,
		}
	} else {
		o.R.PeerStates = append(o.R.PeerStates, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &peerStateR{
				Peer: o,
			}
		} else {
			rel.R.Peer = o
		}
	}
	return nil
}

// AddReferrerPeerStates adds the given related objects to the existing relationships
// of the peer, optionally inserting them as new records.
// Appends related to o.R.ReferrerPeerStates.
// Sets related.R.Referrer appropriately.
func (o *Peer) AddReferrerPeerStates(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*PeerState) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.ReferrerID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"peer_states\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"referrer_id"}),
				strmangle.WhereClause("\"", "\"", 2, peerStatePrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.ReferrerID = o.ID
		}
	}

	if o.R == nil {
		o.R = &peerR{
			ReferrerPeerStates: related,
		}
	} else {
		o.R.ReferrerPeerStates = append(o.R.ReferrerPeerStates, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &peerStateR{
				Referrer: o,
			}
		} else {
			rel.R.Referrer = o
		}
	}
	return nil
}

// AddHostProvideMeasurements adds the given related objects to the existing relationships
// of the peer, optionally inserting them as new records.
// Appends related to o.R.HostProvideMeasurements.
// Sets related.R.Host appropriately.
func (o *Peer) AddHostProvideMeasurements(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*ProvideMeasurement) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.HostID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"provide_measurements\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"host_id"}),
				strmangle.WhereClause("\"", "\"", 2, provideMeasurementPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.HostID = o.ID
		}
	}

	if o.R == nil {
		o.R = &peerR{
			HostProvideMeasurements: related,
		}
	} else {
		o.R.HostProvideMeasurements = append(o.R.HostProvideMeasurements, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &provideMeasurementR{
				Host: o,
			}
		} else {
			rel.R.Host = o
		}
	}
	return nil
}

// AddProviderProviderPeers adds the given related objects to the existing relationships
// of the peer, optionally inserting them as new records.
// Appends related to o.R.ProviderProviderPeers.
// Sets related.R.Provider appropriately.
func (o *Peer) AddProviderProviderPeers(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*ProviderPeer) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.ProviderID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"provider_peers\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"provider_id"}),
				strmangle.WhereClause("\"", "\"", 2, providerPeerPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.ProviderID = o.ID
		}
	}

	if o.R == nil {
		o.R = &peerR{
			ProviderProviderPeers: related,
		}
	} else {
		o.R.ProviderProviderPeers = append(o.R.ProviderProviderPeers, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &providerPeerR{
				Provider: o,
			}
		} else {
			rel.R.Provider = o
		}
	}
	return nil
}

// AddProviderProvides adds the given related objects to the existing relationships
// of the peer, optionally inserting them as new records.
// Appends related to o.R.ProviderProvides.
// Sets related.R.Provider appropriately.
func (o *Peer) AddProviderProvides(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Provide) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.ProviderID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"provides\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"provider_id"}),
				strmangle.WhereClause("\"", "\"", 2, providePrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.ProviderID = o.ID
		}
	}

	if o.R == nil {
		o.R = &peerR{
			ProviderProvides: related,
		}
	} else {
		o.R.ProviderProvides = append(o.R.ProviderProvides, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &provideR{
				Provider: o,
			}
		} else {
			rel.R.Provider = o
		}
	}
	return nil
}

// AddRetrieverRetrievals adds the given related objects to the existing relationships
// of the peer, optionally inserting them as new records.
// Appends related to o.R.RetrieverRetrievals.
// Sets related.R.Retriever appropriately.
func (o *Peer) AddRetrieverRetrievals(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Retrieval) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.RetrieverID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"retrievals\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"retriever_id"}),
				strmangle.WhereClause("\"", "\"", 2, retrievalPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.RetrieverID = o.ID
		}
	}

	if o.R == nil {
		o.R = &peerR{
			RetrieverRetrievals: related,
		}
	} else {
		o.R.RetrieverRetrievals = append(o.R.RetrieverRetrievals, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &retrievalR{
				Retriever: o,
			}
		} else {
			rel.R.Retriever = o
		}
	}
	return nil
}

// AddRoutingTableEntries adds the given related objects to the existing relationships
// of the peer, optionally inserting them as new records.
// Appends related to o.R.RoutingTableEntries.
// Sets related.R.Peer appropriately.
func (o *Peer) AddRoutingTableEntries(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*RoutingTableEntry) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.PeerID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"routing_table_entries\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"peer_id"}),
				strmangle.WhereClause("\"", "\"", 2, routingTableEntryPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.RoutingTableSnapshotID, rel.PeerID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.PeerID = o.ID
		}
	}

	if o.R == nil {
		o.R = &peerR{
			RoutingTableEntries: related,
		}
	} else {
		o.R.RoutingTableEntries = append(o.R.RoutingTableEntries, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &routingTableEntryR{
				Peer: o,
			}
		} else {
			rel.R.Peer = o
		}
	}
	return nil
}

// AddRoutingTableSnapshots adds the given related objects to the existing relationships
// of the peer, optionally inserting them as new records.
// Appends related to o.R.RoutingTableSnapshots.
// Sets related.R.Peer appropriately.
func (o *Peer) AddRoutingTableSnapshots(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*RoutingTableSnapshot) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.PeerID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"routing_table_snapshots\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"peer_id"}),
				strmangle.WhereClause("\"", "\"", 2, routingTableSnapshotPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.PeerID = o.ID
		}
	}

	if o.R == nil {
		o.R = &peerR{
			RoutingTableSnapshots: related,
		}
	} else {
		o.R.RoutingTableSnapshots = append(o.R.RoutingTableSnapshots, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &routingTableSnapshotR{
				Peer: o,
			}
		} else {
			rel.R.Peer = o
		}
	}
	return nil
}

// Peers retrieves all the records using an executor.
func Peers(mods ...qm.QueryMod) peerQuery {
	mods = append(mods, qm.From("\"peers\""))
	return peerQuery{NewQuery(mods...)}
}

// FindPeer retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindPeer(ctx context.Context, exec boil.ContextExecutor, iD int, selectCols ...string) (*Peer, error) {
	peerObj := &Peer{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from \"peers\" where \"id\"=$1", sel,
	)

	q := queries.Raw(query, iD)

	err := q.Bind(ctx, exec, peerObj)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: unable to select from peers")
	}

	if err = peerObj.doAfterSelectHooks(ctx, exec); err != nil {
		return peerObj, err
	}

	return peerObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *Peer) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("models: no peers provided for insertion")
	}

	var err error
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if o.UpdatedAt.IsZero() {
			o.UpdatedAt = currTime
		}
		if o.CreatedAt.IsZero() {
			o.CreatedAt = currTime
		}
	}

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(peerColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	peerInsertCacheMut.RLock()
	cache, cached := peerInsertCache[key]
	peerInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			peerAllColumns,
			peerColumnsWithDefault,
			peerColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(peerType, peerMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(peerType, peerMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO \"peers\" (\"%s\") %%sVALUES (%s)%%s", strings.Join(wl, "\",\""), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO \"peers\" %sDEFAULT VALUES%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			queryReturning = fmt.Sprintf(" RETURNING \"%s\"", strings.Join(returnColumns, "\",\""))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}

	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}

	if err != nil {
		return errors.Wrap(err, "models: unable to insert into peers")
	}

	if !cached {
		peerInsertCacheMut.Lock()
		peerInsertCache[key] = cache
		peerInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// Update uses an executor to update the Peer.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *Peer) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		o.UpdatedAt = currTime
	}

	var err error
	if err = o.doBeforeUpdateHooks(ctx, exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	peerUpdateCacheMut.RLock()
	cache, cached := peerUpdateCache[key]
	peerUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			peerAllColumns,
			peerPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("models: unable to update peers, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE \"peers\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 1, wl),
			strmangle.WhereClause("\"", "\"", len(wl)+1, peerPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(peerType, peerMapping, append(wl, peerPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, values)
	}
	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update peers row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by update for peers")
	}

	if !cached {
		peerUpdateCacheMut.Lock()
		peerUpdateCache[key] = cache
		peerUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(ctx, exec)
}

// UpdateAll updates all rows with the specified column values.
func (q peerQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all for peers")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected for peers")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o PeerSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("models: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), peerPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE \"peers\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), len(colNames)+1, peerPrimaryKeyColumns, len(o)))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all in peer slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected all in update all peer")
	}
	return rowsAff, nil
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *Peer) Upsert(ctx context.Context, exec boil.ContextExecutor, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("models: no peers provided for upsert")
	}
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		o.UpdatedAt = currTime
		if o.CreatedAt.IsZero() {
			o.CreatedAt = currTime
		}
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(peerColumnsWithDefault, o)

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	if updateOnConflict {
		buf.WriteByte('t')
	} else {
		buf.WriteByte('f')
	}
	buf.WriteByte('.')
	for _, c := range conflictColumns {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	peerUpsertCacheMut.RLock()
	cache, cached := peerUpsertCache[key]
	peerUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			peerAllColumns,
			peerColumnsWithDefault,
			peerColumnsWithoutDefault,
			nzDefaults,
		)
		update := updateColumns.UpdateColumnSet(
			peerAllColumns,
			peerPrimaryKeyColumns,
		)

		if updateOnConflict && len(update) == 0 {
			return errors.New("models: unable to upsert peers, could not build update column list")
		}

		conflict := conflictColumns
		if len(conflict) == 0 {
			conflict = make([]string, len(peerPrimaryKeyColumns))
			copy(conflict, peerPrimaryKeyColumns)
		}
		cache.query = buildUpsertQueryPostgres(dialect, "\"peers\"", updateOnConflict, ret, update, conflict, insert)

		cache.valueMapping, err = queries.BindMapping(peerType, peerMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(peerType, peerMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(returns...)
		if err == sql.ErrNoRows {
			err = nil // Postgres doesn't return anything when there's no update
		}
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}
	if err != nil {
		return errors.Wrap(err, "models: unable to upsert peers")
	}

	if !cached {
		peerUpsertCacheMut.Lock()
		peerUpsertCache[key] = cache
		peerUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}

// Delete deletes a single Peer record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *Peer) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("models: no Peer provided for delete")
	}

	if err := o.doBeforeDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), peerPrimaryKeyMapping)
	sql := "DELETE FROM \"peers\" WHERE \"id\"=$1"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete from peers")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by delete for peers")
	}

	if err := o.doAfterDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q peerQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("models: no peerQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from peers")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for peers")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o PeerSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	if len(peerBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), peerPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM \"peers\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, peerPrimaryKeyColumns, len(o))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from peer slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for peers")
	}

	if len(peerAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *Peer) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindPeer(ctx, exec, o.ID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *PeerSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := PeerSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), peerPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT \"peers\".* FROM \"peers\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, peerPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "models: unable to reload all in PeerSlice")
	}

	*o = slice

	return nil
}

// PeerExists checks if the Peer row exists.
func PeerExists(ctx context.Context, exec boil.ContextExecutor, iD int) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from \"peers\" where \"id\"=$1 limit 1)"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, iD)
	}
	row := exec.QueryRowContext(ctx, sql, iD)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "models: unable to check if peers exists")
	}

	return exists, nil
}
